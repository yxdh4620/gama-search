// Generated by CoffeeScript 1.7.1

/*
 * User YuanXiangDong
 * Date 14-10-14
 * aliyun search main
 * aliyun开放式搜索的接口实现
 */

(function() {
  var GET_HTTP_METHOD, POST_HTTP_METHOD, SEARCH_LIST_SIZE, SIGN_MODE, SearchManager, assert, cryptoUtil, path, request, urlEncode, urlUtil, _, _makeFields, _makeFilter, _makeMultipleIdStr;

  assert = require("assert");

  urlUtil = require('url');

  request = require('request');

  path = require('path');

  cryptoUtil = require('./utils/crypto_util');

  _ = require("underscore");

  urlEncode = require('./utils/url_encode');

  SIGN_MODE = 1;

  GET_HTTP_METHOD = "GET";

  POST_HTTP_METHOD = "POST";

  SEARCH_LIST_SIZE = 40;

  _makeFilter = function(filter) {
    var filterStr, step, val, _i, _len;
    filterStr = '';
    if (filter != null) {
      if (_.isString(filter)) {
        filterStr = filter;
      } else if (_.isArray(filter)) {
        for (step = _i = 0, _len = filter.length; _i < _len; step = _i += 3) {
          val = filter[step];
          filterStr += "contain(" + val + ", \"" + filter[step + 1] + "\") " + (filter[step + 2] || '') + " ";
        }
      }
    }
    return filterStr;
  };

  _makeFields = function(fields) {
    var str, val, _i, _len;
    if (_.isString(fields)) {
      return fields;
    }
    if (_.isArray(fields)) {
      str = "";
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        val = fields[_i];
        str += "" + val + ";";
      }
      return str.substring(0, str.length - 1);
    }
    return null;
  };

  _makeMultipleIdStr = function(ids) {
    var str, val, _i, _len;
    if (_.isString(ids)) {
      return ids;
    }
    if (_.isArray(ids)) {
      str = "";
      for (_i = 0, _len = ids.length; _i < _len; _i++) {
        val = ids[_i];
        str += "id:'" + val + "' OR ";
      }
      return str.substring(0, str.length - 3);
    }
    return null;
  };

  SearchManager = (function() {
    function SearchManager(searchOptions) {
      assert(searchOptions, "missing options");
      assert(searchOptions.accessKeyId, "missing opensearch key id");
      assert(searchOptions.accessKeySecret, "missing opensearch key secret");
      this.accessKeyId = searchOptions.accessKeyId;
      this.accessKeySecret = searchOptions.accessKeySecret;
      this.apiURL = searchOptions.apiURL || 'http://opensearch.aliyuncs.com';
      this.version = searchOptions.version || 'v2';
      this.format = searchOptions.format || 'json';
      this.timeout = searchOptions.timeout || 3000;
      this.dataType = searchOptions.dataType || 'json';
      this.serverURL = this.apiURL;
      this.indexName = searchOptions.indexName || 'test';
      this.signatureMethod = searchOptions.signatureMethod || 'HMAC-SHA1';
      this.signatureVersion = searchOptions.signatureVersion || '1.0';
      this.pageSize = searchOptions.pageSize || SEARCH_LIST_SIZE;
    }

    SearchManager.prototype.insert = function(items, table_name, callback) {
      var cmd, params, query, url, val, _i, _len;
      assert(Array.isArray(items) && items.length > 0, "missing options");
      assert(table_name, "missing table_name");
      assert(_.isFunction(callback), "missing callback");
      url = urlUtil.resolve(this.serverURL, path.join("index/doc", this.indexName));
      cmd = 'add';
      query = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        val = items[_i];
        query.push({
          cmd: cmd,
          fields: val
        });
      }
      params = {
        action: 'push',
        items: JSON.stringify(query),
        table_name: table_name,
        sing_mode: "" + SIGN_MODE
      };
      this.apiCall(url, params, POST_HTTP_METHOD, callback);
    };

    SearchManager.prototype.update = function(items, table_name, callback) {
      var cmd, params, query, url, val, _i, _len;
      assert(Array.isArray(items) && items.length > 0, "missing options");
      assert(table_name, "missing table_name");
      assert(_.isFunction(callback), "missing callback");
      url = urlUtil.resolve(this.serverURL, path.join("index/doc", this.indexName));
      cmd = 'update';
      query = [];
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        val = items[_i];
        query.push({
          cmd: cmd,
          fields: val
        });
      }
      params = {
        action: 'push',
        items: JSON.stringify(query),
        table_name: table_name,
        sing_mode: "" + SIGN_MODE
      };
      this.apiCall(url, params, POST_HTTP_METHOD, callback);
    };

    SearchManager.prototype.searchById = function(id, filter, callback) {
      var options, params, url;
      url = urlUtil.resolve(this.serverURL, path.join('search'));
      params = this.loadPublicParams();
      params['query'] = "config=fromat:json,start:0,hit:" + this.pageSize + "&&query=id:'" + id + "'&&filter=" + (_makeFilter(filter));
      params['index_name'] = this.indexName;
      params['Signature'] = cryptoUtil.makeSign(params, GET_HTTP_METHOD, this.accessKeySecret);
      options = {
        url: "" + url + "?" + (urlEncode.query2string(params)),
        method: GET_HTTP_METHOD,
        timeout: this.timeout
      };
      request(options, (function(_this) {
        return function(err, res, body) {
          body = _this._parseResult(body);
          callback(err, body);
        };
      })(this));
    };

    SearchManager.prototype.searchByMultipleId = function(ids, filter, callback) {
      var options, params, queryStr, url;
      url = urlUtil.resolve(this.serverURL, path.join('search'));
      params = this.loadPublicParams();
      queryStr = _makeMultipleIdStr(ids);
      params['query'] = "config=fromat:json,start:0,hit:" + this.pageSize + "&&query=" + queryStr + "&&filter=" + (_makeFilter(filter));
      params['index_name'] = this.indexName;
      params['Signature'] = cryptoUtil.makeSign(params, GET_HTTP_METHOD, this.accessKeySecret);
      options = {
        url: "" + url + "?" + (urlEncode.query2string(params)),
        method: GET_HTTP_METHOD,
        timeout: this.timeout
      };
      request(options, (function(_this) {
        return function(err, res, body) {
          body = _this._parseResult(body);
          callback(err, body);
        };
      })(this));
    };

    SearchManager.prototype.search = function(queryStr, fieldName, filter, page, pageSize, callback) {
      var options, params, start, url;
      if (!(_.isNumber(page) && page > 0)) {
        page = 1;
      }
      if (_.isFunction(pageSize)) {
        callback = pageSize;
        pageSize = null;
      }
      start = (page - 1) * (pageSize || this.pageSize);
      url = urlUtil.resolve(this.serverURL, path.join('search'));
      params = this.loadPublicParams();
      fieldName = fieldName || 'default';
      params['query'] = "config=fromat:json,start:" + start + ",hit:" + (pageSize || this.pageSize) + "&&query=" + fieldName + ":'" + queryStr + "'&&filter=" + (_makeFilter(filter));
      params['index_name'] = this.indexName;
      params['Signature'] = cryptoUtil.makeSign(params, GET_HTTP_METHOD, this.accessKeySecret);
      options = {
        url: "" + url + "?" + (urlEncode.query2string(params)),
        method: GET_HTTP_METHOD,
        timeout: this.timeout
      };
      request(options, (function(_this) {
        return function(err, res, body) {
          if (!err) {
            body = _this._parseResult(body, page, pageSize);
          }
          callback(err, body);
        };
      })(this));
    };

    SearchManager.prototype.advancedSearch = function(queryStr, fieldName, page, subQuerys, others, pageSize, callback) {
      var field, options, params, query, start, url;
      if (!(_.isNumber(page) && page > 0)) {
        page = 1;
      }
      if (_.isFunction(pageSize)) {
        callback = pageSize;
        pageSize = null;
      }
      start = (page - 1) * (pageSize || this.pageSize);
      url = urlUtil.resolve(this.serverURL, path.join('search'));
      params = this.loadPublicParams();
      fieldName = fieldName || 'default';
      subQuerys = subQuerys || {};
      others = others || {};
      query = "config=fromat:json,start:" + start + ",hit:" + (pageSize || this.pageSize) + "&&query=" + fieldName + ":'" + queryStr + "'";
      if ((subQuerys.aggregate != null) && _.isString(subQuerys.aggregate)) {
        query += "&&aggregate=" + subQuerys.aggregate;
      }
      if ((subQuerys.sort != null) && _.isString(subQuerys.sort)) {
        query += "&&sort=" + subQuerys.sort;
      }
      if ((subQuerys.distinct != null) && _.isString(subQuerys.distinct)) {
        query += "&&distinct=" + subQuerys.distinct;
      }
      if (subQuerys.filter != null) {
        query += "&&filter=" + (_makeFilter(subQuerys.filter));
      }
      params['query'] = query;
      params['index_name'] = this.indexName;
      if (others.fetch_fields != null) {
        field = _makeFields(others.fetch_fields);
        if (field != null) {
          params['fetch_fields'] = _makeFields(others.fetch_fields);
        }
      }
      if ((others.formula_name != null) && _.isString(others.formula_name)) {
        params['formula_name'] = others.formula_name;
      }
      if ((others.first_formula_name != null) && _.isString(others.first_formula_name)) {
        params['first_formula_name'] = other.first_formula_name;
      }
      if ((others.summary != null) && _.isString(others.summary)) {
        params['summary'] = others.summary;
      }
      params['Signature'] = cryptoUtil.makeSign(params, GET_HTTP_METHOD, this.accessKeySecret);
      options = {
        url: "" + url + "?" + (urlEncode.query2string(params)),
        method: GET_HTTP_METHOD,
        timeout: this.timeout
      };
      request(options, (function(_this) {
        return function(err, res, body) {
          if (!err) {
            body = _this._parseResult(body, page, pageSize);
          }
          callback(err, body);
        };
      })(this));
    };

    SearchManager.prototype["delete"] = function(ids, table_name, callback) {
      var cmd, params, query, url;
      assert(Array.isArray(ids) && ids.length > 0, "missing options");
      assert(table_name, "missing table_name");
      assert(_.isFunction(callback), "missing callback");
      url = urlUtil.resolve(this.serverURL, path.join("index/doc", this.indexName));
      cmd = 'delete';
      query = [];
      ids.map(function(id) {
        return query.push({
          cmd: cmd,
          fields: {
            id: id
          }
        });
      });
      params = {
        action: 'push',
        items: JSON.stringify(query),
        table_name: table_name,
        sing_mode: "" + SIGN_MODE
      };
      this.apiCall(url, params, POST_HTTP_METHOD, callback);
    };

    SearchManager.prototype.deleteByField = function(field, ids, table_name, callback) {
      var cmd, params, query, url;
      assert(Array.isArray(ids) && ids.length > 0, "missing options");
      assert(_.isString(field) && field.length > 0, "missing options");
      assert(table_name, "missing table_name");
      assert(_.isFunction(callback), "missing callback");
      url = urlUtil.resolve(this.serverURL, path.join("index/doc", this.indexName));
      cmd = 'delete';
      query = [];
      ids.map(function(id) {
        var fields;
        fields = {};
        fields[field] = id;
        return query.push({
          cmd: cmd,
          fields: fields
        });
      });
      params = {
        action: 'push',
        items: JSON.stringify(query),
        table_name: table_name,
        sing_mode: "" + SIGN_MODE
      };
      this.apiCall(url, params, POST_HTTP_METHOD, callback);
    };

    SearchManager.prototype.suggest = function(keyword, indexName, suggestName, callback) {
      var params, url;
      params = {
        query: keyword,
        index_name: indexName,
        suggest_name: suggestName
      };
      url = urlUtil.resolve(this.serverURL, path.join("suggest"));
      return this.apiCall(url, params, GET_HTTP_METHOD, callback);
    };

    SearchManager.prototype.loadPublicParams = function() {
      var publicParams;
      publicParams = {};
      publicParams.Version = this.version;
      publicParams.AccessKeyId = this.accessKeyId;
      publicParams.SignatureMethod = 'HMAC-SHA1';
      publicParams.SignatureVersion = '1.0';
      publicParams.SignatureNonce = cryptoUtil.makeNonce(this.accessKeyId, this.accessKeySecret);
      publicParams.Timestamp = new Date(new Date().getTime() - 28800000).Format("yyyy-MM-ddThh:mm:ssZ");
      return publicParams;
    };

    SearchManager.prototype.apiCall = function(url, params, httpMethod, callback) {
      var options, queryParams, queryString;
      queryParams = this.loadPublicParams();
      queryParams.Signature = cryptoUtil.makeSign(_.extend(queryParams, params), httpMethod, this.accessKeySecret);
      queryString = urlEncode.query2string(_.extend(params, queryParams));
      if (httpMethod === GET_HTTP_METHOD) {
        url = "" + url + "?" + queryString;
      }
      options = {
        url: "" + url,
        method: httpMethod,
        timeout: this.timeout
      };
      if (httpMethod === POST_HTTP_METHOD) {
        options.form = queryString;
      }
      request(options, (function(_this) {
        return function(err, res, body) {
          body = _this._parseResult(body);
          callback(err, body);
        };
      })(this));
    };

    SearchManager.prototype._parseResult = function(data, page, pageSize) {
      var result;
      if (!data) {
        return data;
      }
      data = JSON.parse(data);
      if (page == null) {
        return data;
      }
      if (data.status !== 'OK') {
        return data;
      }
      result = data.result;
      if (!result) {
        return data;
      }
      result['page'] = page;
      pageSize || (pageSize = this.pageSize);
      result['pagetotal'] = parseInt((result.viewtotal + pageSize - 1) / pageSize);
      data.result = result;
      return data;
    };

    return SearchManager;

  })();

  module.exports = SearchManager;

}).call(this);
